# 动态规划问题的一般形式就是求最值，本质就是穷举。

常见的方案是「备忘录」或者「DP table」，特殊情况可以只保存最近的几个数据的解，这种特殊情况只在迭代的算法中才会实现。
备忘录实际上就是对递归（自上而下）的树进行了剪枝
DP table实际上就是迭代（自下而上），求解问题，如果只保存最近几个数据就可以，那DP table的规模就可以进一步缩小，也就是上百纳说的那种特殊请情况。


通俗一点来讲，动态规划和其它遍历算法(如深/广度优先搜索)都是将原问题拆成多个子问题然后求解，
他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，
这样我们可以通过计算和储存子问题的解来求解最终问题。

我们可以认为，动态规划=递归+记忆，也可以称作记忆化递归，

写动态规划的逻辑思路：（最简单的例子就是斐波那契数列）
    先想递归
    发现重复计算
    通过记忆化等方法弄掉重复计算
    最后看下能不能通过利用计算顺序来做到去掉递归用“刷表”方式直接顺序计算，能搞定最好搞不定拉倒


首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，
只有列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。
另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。

明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。


# 自顶向下递归的动态规划
    def dp(状态1, 状态2, ...):
        for 选择 in 所有可能的选择:
            # 此时的状态已经因为做了选择而改变
            result = 求最值(result, dp(状态1, 状态2, ...))
        return result

# 自底向上迭代的动态规划
    # 初始化 base case
    dp[0][0][...] = base case
    # 进行状态转移
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2...)


「状态转移方程」这个名词，实际上就是描述问题结构的数学形式


## 回溯算法和动态规划有什么区别和联系
回溯算法和动态规划都是求解问题的常用算法，它们有些相似之处，但也有不同之处。

区别：

目标不同：回溯算法旨在找到所有可能的解决方案，而动态规划则旨在寻找最优解。
计算方式不同：回溯算法通常采用递归的方式，通过尝试不同的选择，搜索所有可能的解决方案；而动态规划则是通过记录中间结果，避免重复计算，实现高效求解最优解。
适用范围不同：回溯算法通常用于组合优化问题，如求解排列、组合、子集等；而动态规划通常用于最优化问题，如求解最长子序列、最短路径等。
联系：

都是通过状态转移来求解问题，回溯算法通过不断尝试不同的选择来转移状态，动态规划通过利用已经求解过的中间结果来转移状态。
动态规划问题中，某些问题可以转化为回溯问题，如最长公共子序列问题、背包问题等。
需要根据具体问题的特点，选择合适的算法进行求解。


## 动态规划中，怎么判断dp 的长度是n ，还是n+1?
在动态规划中，我们通常会定义一个dp数组来存储子问题的解，但是在定义dp数组时，我们需要考虑到该数组的下标范围，即该数组的长度。

通常情况下，dp数组的长度应该是原问题规模的一个函数，通常是原问题规模的大小加1，即dp数组长度为n+1。

这是因为动态规划的过程中，我们通常会使用一个小规模的子问题的解来逐步求解大规模问题的解，而dp数组的长度应该是能够容纳所有子问题的规模的，因此需要加1。

但是，有时候我们也可以将dp数组的长度定义为原问题规模的大小，这通常是在问题的定义中已经包含了一个特殊情况的解，例如在斐波那契数列问题中，我们可以将dp数组的长度定义为n，因为斐波那契数列的定义中已经包含了前两个元素为1的情况，因此我们只需要计算第三个元素之后的斐波那契数列元素即可。



